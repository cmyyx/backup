/**
 * @description
 * 终极解决方案 (定稿):
 * 1. 本脚本与您的覆写配置协同工作，将订阅信息展示在一个专属的代理组中。
 * 2. 它会找到原始的信息节点，提取数据，然后将其销毁。
 * 3. 它会创建一个干净、单行、以“Info-”为前缀的“虚拟信息节点”。
 * 4. 这个虚拟节点会被您在覆写配置中预设的“订阅信息”组通过 filter 捕获。
 * 5. 最终实现信息分离、优雅展示，且不污染任何其他代理组。
 *
 * @author Gemini
 */
function operator(proxies) {
    const providerTagRegex = /\[(.*?)\]/;
    const infoNodeKeywords = ['剩余流量', '套餐到期', '重置'];
    const trafficRegex = /剩余流量[\s:：]*([\d.]+[\s]*GB)/;
    const expiryRegex = /套餐到期[\s:：]*(\d{4}-\d{2}-\d{2})/;
    const infoNodePrefix = 'Info-'; // 这是与您配置中 filter 对应的“接头暗号”

    const infoNodesToRemove = [];
    const newInfoNodesToAdd = [];

    const providers = new Map();

    // 先把所有节点按服务商标签分组
    proxies.forEach(p => {
        const tagMatch = p.name.match(providerTagRegex);
        if (tagMatch && tagMatch[1]) {
            const providerName = tagMatch[1];
            if (!providers.has(providerName)) {
                providers.set(providerName, { infoNode: null, realNodes: [] });
            }
            const providerData = providers.get(providerName);
            const isInfoNode = infoNodeKeywords.some(keyword => p.name.includes(keyword));

            if (isInfoNode) {
                providerData.infoNode = p;
                infoNodesToRemove.push(p.name); // 记录下这个原始信息节点，稍后删除
            }
        }
    });

    // 遍历分组，生成新的“虚拟信息节点”
    providers.forEach((data, providerName) => {
        if (data.infoNode) {
            const trafficInfo = data.infoNode.name.match(trafficRegex)?.[1]?.trim() || 'N/A';
            const expiryInfo = data.infoNode.name.match(expiryRegex)?.[1]?.trim() || 'N/A';

            // 构建干净、单行的新节点名
            const newName = `${infoNodePrefix}${providerName} | 流量: ${trafficInfo} | 到期: ${expiryInfo}`;

            // 创建一个假的、无法使用的代理节点对象，它只作为标签存在
            const fakeNode = {
                name: newName,
                type: 'ss', // 协议可以是任意无害的类型
                server: '127.0.0.1',
                port: 1,
                password: 'fake',
                cipher: 'aes-128-gcm'
            };
            newInfoNodesToAdd.push(fakeNode);
        }
    });

    // 从原始节点列表中，先删除掉丑陋的旧信息节点
    let finalProxies = proxies.filter(p => !infoNodesToRemove.includes(p.name));
    
    // 然后将我们创造的、干净的新信息节点加进去
    finalProxies = newInfoNodesToAdd.concat(finalProxies);
    
    return finalProxies;
}